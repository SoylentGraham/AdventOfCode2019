<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="Editor_win95.css" />
<style>
</style>
</head>
<body>
	
<script>
	
	function ParsePath(PathString)
	{
		//	turn into array of [ [DIR,COUNT], ... ]
		function InstructionToDirCount(Instruction)
		{
			const Dir = Instruction[0];
			const Count = parseFloat( Instruction.substring(1) );
			
			return {'Direction':Dir,'Count':Count};
		}
		
		const Instructions = PathString.split(',');
		const Path = Instructions.map( InstructionToDirCount );
		return Path;
	}

	const Map0_Wire1 = ParsePath('R8,U5,L5,D3');
	const Map0_Wire2 = ParsePath('U7,R6,D4,L4');
	const Map0_Distance = 6;


	const Map1_Wire1 = ParsePath('R75,D30,R83,U83,L12,D49,R71,U7,L72');
	const Map1_Wire2 = ParsePath('U62,R66,U55,R34,D71,R55,D58,R83');
	const Map1_Distance = 159;
	
	const Map2_Wire1 = ParsePath('R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51');
	const Map2_Wire2 = ParsePath('U98,R91,D20,R16,D67,R40,U7,R15,U6,R7');
	const Map2_Distance = 135;
	
	const Map3_Wire1 = ParsePath('R991,U557,R554,U998,L861,D301,L891,U180,L280,D103,R828,D58,R373,D278,L352,D583,L465,D301,R384,D638,L648,D413,L511,U596,L701,U463,L664,U905,L374,D372,L269,U868,R494,U294,R661,U604,L629,U763,R771,U96,R222,U227,L97,D793,L924,U781,L295,D427,R205,D387,L455,D904,R254,D34,R341,U268,L344,D656,L715,U439,R158,U237,R199,U729,L428,D125,R487,D506,R486,D496,R932,D918,R603,U836,R258,U15,L120,U528,L102,D42,R385,U905,L472,D351,R506,U860,L331,D415,R963,D733,R108,D527,L634,U502,L553,D623,R973,U209,L632,D588,R264,U553,L768,D689,L708,D432,R247,U993,L146,U656,R710,U47,R783,U643,R954,U888,L84,U202,R495,U66,R414,U993,R100,D557,L326,D645,R975,U266,R143,U730,L491,D96,L161,U165,R97,D379,R930,D613,R178,D635,R192,U957,L450,U149,R911,U220,L914,U659,L67,D825,L904,U137,L392,U333,L317,U310,R298,D240,R646,U588,R746,U861,L958,D892,L200,U463,R246,D870,R687,U815,R969,U864,L972,U254,L120,D418,L567,D128,R934,D217,R764,U128,R146,U467,R690,U166,R996,D603,R144,D362,R885,D118,L882,U612,R270,U917,L599,D66,L749,D498,L346,D920,L222,U439,R822,U891,R458,U15,R831,U92,L164,D615,L439,U178,R409,D463,L452,U633,L683,U186,R402,D609,L38,D699,L679,D74,R125,D145,R424,U961,L353,U43,R794,D519,L359,D494,R812,D770,L657,U154,L137,U549,L193,D816,R333,U650,R49,D459,R414,U72,R313,U231,R370,U680,L27,D221,L355,U342,L597,U748,R821,D280,L307,U505,L160,U982,L527,D516,L245,U158,R565,D797,R99,D695,L712,U155,L23,U964,L266,U623,L317,U445,R689,U150,L41,U536,R638,D200,R763,D260,L234,U217,L881,D576,L223,U39,L808,D125,R950,U341,L405');
	const Map3_Wire2 = ParsePath('L993,D508,R356,U210,R42,D68,R827,D513,L564,D407,L945,U757,L517,D253,R614,U824,R174,D536,R906,D291,R70,D295,R916,D754,L892,D736,L528,D399,R76,D588,R12,U617,R173,D625,L533,D355,R178,D706,R139,D419,R460,U976,L781,U973,L931,D254,R195,U42,R555,D151,R226,U713,L755,U398,L933,U264,R352,U461,L472,D810,L257,U901,R429,U848,L181,D362,R404,D234,L985,D392,R341,U608,L518,D59,L804,D219,L366,D28,L238,D491,R265,U131,L727,D504,R122,U461,R732,D411,L910,D884,R954,U341,L619,D949,L570,D823,R646,D226,R197,U892,L691,D294,L955,D303,R490,D469,L503,D482,R390,D741,L715,D187,R378,U853,L70,D903,L589,D481,L589,U911,R45,U348,R214,D10,R737,D305,R458,D291,R637,D721,R440,U573,R442,D407,L63,U569,L903,D936,R518,U859,L370,D888,R498,D759,R283,U469,R548,D185,R808,D81,L629,D761,R807,D878,R712,D183,R382,D484,L791,D371,L188,D397,R645,U679,R415,D446,L695,U174,R707,D36,R483,U877,L819,D538,L277,D2,R200,D838,R837,U347,L865,D945,R958,U575,L924,D351,L881,U961,R899,U845,R816,U866,R203,D380,R766,D97,R38,U148,L999,D332,R543,U10,R351,U281,L460,U309,L543,U795,L639,D556,L882,D513,R722,U314,R531,D604,L418,U840,R864,D694,L530,U862,R559,D639,R689,D201,L439,D697,R441,U175,R558,D585,R92,D191,L533,D788,R154,D528,R341,D908,R811,U750,R172,D742,R113,U56,L517,D826,L250,D269,L278,U74,R285,U904,L221,U270,R296,U671,L535,U340,L206,U603,L852,D60,R648,D313,L282,D685,R482,U10,R829,U14,L12,U365,R996,D10,R104,U654,R346,D458,R219,U247,L841,D731,R115,U400,L731,D904,L487,U430,R612,U437,L865,D618,R747,U522,R309,U302,R9,U609,L201');

	//const MapSize = 11;
	//const StartPos = [1,8];
	const MapSize = 25000;
	const StartPos = [10000,10000];

	function GetDelta(Instruction)
	{
		if ( Instruction.Direction == 'L' )	return [-1,0];
		if ( Instruction.Direction == 'R' )	return [1,0];
		if ( Instruction.Direction == 'U' )	return [0,-1];
		if ( Instruction.Direction == 'D' )	return [0,1];
		throw "Unknown direction " + Instruction;
	}
	
	function WritePath(Map,Path,WireIndex,OnCross)
	{
		const Pos = StartPos.slice();
		
		function WritePosition(Position)
		{
			//	check bounds
			const MapWidth = Map.length;
			const MapHeight = Map[0].length;
			const x = Position[0];
			const y = Position[1];
			if ( x < 0 || x >= MapWidth )	throw `Position out of bounds ${Position} [${MapWidth},${MapHeight}]`;
			if ( y < 0 || y >= MapHeight )	throw `Position out of bounds ${Position} [${MapWidth},${MapHeight}]`;
			
			//	mark this wire is here
			Map[x][y] |= 1<<WireIndex;
			
			//	there are other bits here!
			const WireBits = Map[x][y];
			if ( WireBits != (1<<WireIndex) )
			{
				OnCross( [x,y], WireBits );
			}
			
		}
		
		function LogoThisMother(Instruction)
		{
			const OldPos = Pos.slice();
			const Delta = GetDelta( Instruction );
			
			for ( let d=0;	d<=Instruction.Count;	d++ )
			{
				//	this is a silly way to move
				Pos[0] = OldPos[0]+(Delta[0]*d);
				Pos[1] = OldPos[1]+(Delta[1]*d);
				WritePosition( Pos );
			}
		}
		Path.forEach( LogoThisMother );
	}

	function PositionMatch(a,b)
	{
		return (a[0]==b[0]) && (a[1]==b[1]);
	}

	function EvaluteMap(Paths,ExpectedIntersections,ClosestIntersectionToStart)
	{
		const Map = [];//new Array(MapSize);
		for ( let i=0;	i<MapSize;	i++ )
			Map[i] = new Uint8Array(MapSize).fill(0);
		const Intersections = [];
		
		function OnIntersection(xy,Bits)
		{
			//	ignore where wires start
			if ( PositionMatch(xy,StartPos) )
				return;
			console.log(`Intersection at ${xy} ${Bits}`);
			Intersections.push(xy.slice());
		}
		
		function ProcessPath(Path,PathIndex)
		{
			WritePath( Map, Path, PathIndex, OnIntersection );
		}
		Paths.forEach( ProcessPath );
		
		console.log("Intersections: ",Intersections);
		
		//	make sure ExpectedIntersections are hit
		if ( ExpectedIntersections )
		{
			for ( const ExpectedIntersection of ExpectedIntersections )
			{
				const Match = Intersections.find( ipos => PositionMatch(ipos,ExpectedIntersection) );
				if ( !Match )
					throw `Expected intersection ${ExpectedIntersection} not found`;
			}
		}
		
		function GetIntersectionDistance(Position)
		{
			//	get distance from start
			const x = Math.abs(Position[0] - StartPos[0]);
			const y = Math.abs(Position[1] - StartPos[1]);
			return x+y;
		}
		//	https://stackoverflow.com/a/1063027/355753
		function sortNumber(a, b)
		{
			return a - b;
		}
		const Distances = Intersections.map( GetIntersectionDistance ).sort(sortNumber);
		
		if ( ClosestIntersectionToStart )
		{
			//	test distance
			if ( Distances[0] != ClosestIntersectionToStart )
			throw `Closest distance ${Distances} didn't match expected ${ClosestIntersectionToStart}`;
		}
		
		console.log("Closest distance",Distances);
		return Distances[0];
	}


	async function Run()
	{
		//EvaluteMap( [Map0_Wire1, Map0_Wire2], undefined/*[ [7,3],[4,5] ]*/, Map0_Distance );
		//EvaluteMap( [Map1_Wire1, Map1_Wire2], undefined, Map1_Distance );
		//EvaluteMap( [Map2_Wire1, Map2_Wire2], undefined, Map2_Distance );
		EvaluteMap( [Map3_Wire1, Map3_Wire2] );

	}

	Run().then( console.log ).catch( console.error );

</script>
	
</body>

